\documentclass{article}
\usepackage{amsmath,textcomp,amssymb,geometry,graphicx,enumerate}

\def\Name{Ran Liao}  % Your name
\def\SID{3034504227}  % Your student ID number
\def\Homework{2} % Number of Homework
\def\Session{Spring 2019}

\title{Explanation for Project 1}
\author{\Name, SID \SID}
\markboth{CS161--\Session\ }{CS161--\Session\ }
\pagestyle{myheadings}
\date{\today}

\textheight=9in
\textwidth=6.5in
\topmargin=-.75in
\oddsidemargin=0.25in
\evensidemargin=0.25in

\begin{document}
\maketitle

\section{Behind the Scenes}

Function $deja\_vu()$ uses $gets()$ to receive input from user without checking array bound properly. Therefore, a long input string can easily overwrite the return address in $deja\_vu()$ stack frame. 

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{stack1.png}
\caption{\label{fig:stack1}Stack Layout}
\end{figure}

Figure \ref{fig:stack1} demonstrates the memory layout of this buggy program. $Door$ is a 16-bytes buffer, $sbp$ is a 4 bytes integer, and there're another 16 bytes padding between them. In total, malicious input should start with 20 bytes padding. Then, the value of 0xBFFFFDC0 will be written to the next location. This is where the return address be stored. And this value is actually the address right behind this location, in which the malicious shellcode will be injected. 

The address of $sbp$ can be retrieved by letting gdb print the value of $ebp$ register. Add 4 to it will get the correct address that need be written during overflow process.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{gdb1.png}
\caption{\label{fig:gdb1}Retrieve Memory Address}
\end{figure}

\newpage
\section{Compromising Further}

This program uses \textbf{char} to receive an integer that used to check array access boundary. However, \textbf{char}
 is a signed data type, which means it can be negative. Thus by passing a negative value to it, e.g., 0xFF, we can bypass the boundary checking and initiate an overflow attack.
 
 \begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{stack2.png}
\caption{\label{fig:stack2}Stack Layout}
\end{figure}

The first byte of my malicious input is 0xFF, which is used to bypass the boundary checking. $msg$ is a 128-bytes long buffer, which have enough space to put the shellcode. Then, another 105 bytes no-sense padding is introduced. As figure \ref{fig:stack2} demonstrates, the next location is the return address we need to overwrite. The correct value is 0xBFFFFCF8. This is the address of variable $msg$ as well as where the shellcode is put. It's position relative to $sbp$ can be calculated by reading assembly codes carefully, and the address of $sbp$ can be printed by gdb.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{gdb2.png}
\caption{\label{fig:gdb2}EIP value}
\end{figure}

In figure \ref{fig:gdb2}, I use gdb to print the value in $eip$ register. As you can see, it changed to 0xBFFFFCF8, which means I hijacked the control flow.

\newpage
\section{Deep Infiltration}

In line 9, this buggy code miscalculated the length of array when checking the boundary. Therefore, it allows us to initiate an overflow attack and overwrite 1 byte.

There're two stage in this attack. 

First, the shellcode is injected into environment variable. This is done by \textbf{egg} script.  Figure \ref{fig:gdb3} shows how to determine the address of injected shellcode in environment variable.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{gdb3.png}
\caption{\label{fig:gdb3}Retrive Shellcode Address}
\end{figure}

Second, I initiate an off-by-one overflow attack. Variable $buf$ is adjacent to $sbp$. Therefore, the least significant byte in $sbp$ will be overwrote. I let this byte be 0x10, which is the least significant part of $buf$'s starting address.

 \begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{stack3.png}
\caption{\label{fig:stack3}Stack Layout}
\end{figure}

After $flip()$ finish and return control to function $invoke()$. The $ebp$ register will have the wrong value pointing to variable $buf$. Then, the malicious address injected into $buf$ will be pop into $eip$ register when function $invoke()$ finish. Figure \ref{fig:gdb4} demonstrate how $eip$ register changed after hijacking.

\begin{figure}[h]
\centering
\includegraphics[width=0.55\textwidth]{gdb4.png}
\caption{\label{fig:gdb4}EIP value}
\end{figure}

\newpage
\section{Secret Exfiltration}

This program will not behave properly if invalid input data is given to it. Specifically, if the last 4 bytes of input data is `$\backslash$', `x', `$\backslash$n' and `$\backslash$0' respectively, the bound checking of line 20 will fail. Therefore, more data behind this address can be printed.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{stack4.png}
\caption{\label{fig:stack4}Stack Layout}
\end{figure}

As demonstrated in figure \ref{fig:stack4}, the \textbf{canary} is right behind variable $buffer$. Therefore this overflow attack can be conducted in two steps. First, construct an invalid input string described early to retrieve the value of \textbf{canary}. Second, inject shellcode and overwrite \textbf{canary} correctly to avoid program from crashing. Again, the relative position of return address can be calculated after reading assembly codes carefully. And the value of $ebp$ register can be printed by gdb.

The first attack string should like this, `$\backslash$ x30 $\backslash$ x30 $\backslash$ x30 $\backslash$ x'. The 4th to 8th value in response string will be the \textbf{canary}'s value.

The second attack string will be like this,
\[
 'A' * 32 + \textbf{canary} +  'A' * 8 + '\backslash xd4 \backslash xfd \backslash xff \backslash xbf' + \textbf{SHELLCODE} + '\backslash n'
 \]

The length of A padding is 32. This is because all result will be copied to $answer$ by this program, thus, 16 more padding is needed.

\newpage
\section{The Last Bastion}

There's a magic number $58623$ in the buggy program, which is $ffe4$ in hexadecimal. And it is $jmp  *\%esp$ when interpreted as executable instruction. This instruction is not protected by ASLR, which means we can obtain its exact address. Figure \ref{fig:gdb5} demonstrate how to find this instruction is gdb. 

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{gdb5.png}
\caption{\label{fig:gdb5}Address of  $jmp *\%esp$}
\end{figure}

This vulnerability makes it possible to initiate a \textbf{ret2esp} attack, which can bypass ASLR.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{stack5.png}
\caption{\label{fig:stack5}Stack Layout}
\end{figure}

Figure \ref{fig:stack5} demonstrate the memory layout before and after attack. Shellcode is placed right behind RIP, and RIP is redirected to  $jmp  *\%esp$ instruction.


\end{document}